# 学習ログ Vol.4：通知・バッチ機能の実装

## 1. 概要
タスクの期限を自動的に監視し、期限が近い（または切れている）未完了タスクをユーザーの画面へ通知する機能を実装した。

## 2. 実装のポイント
### ① Spring Scheduling による自動実行
`@EnableScheduling` と `@Scheduled` を活用し、バックグラウンドで定期的にタスクをチェックするバッチ処理を構築した。
- **柔軟なスケジュール設定**: Cron形式（`0 0 9 * * *`）を用いて、実行タイミングを制御する方法を習得した。

### ② 通知（Notification）の永続化
バッチ処理の結果を即座に表示するのではなく、DB（`Notification` エンティティ）に保存する非同期的な通知方式を採用した。
- **データ構造**: `User` との紐付けによる個人宛通知、`Task` との紐付けによる対象タスクの特定、および `isRead` フラグによる未読管理を実現。

### ③ 実務的な重複防止ロジック
バッチが実行されるたびに同じ通知が重ならないよう、`existsByTaskIdAndIsReadFalse` メソッドを使用して「未読の通知が既に存在する場合は新規作成をスキップする」制御を実装した。

### ④ 既読処理のUI/UX
Bootstrapの警告（Alert）コンポーネントと `POST` メソッドを組み合わせ、通知の「×」ボタンを押した際にDBの既読フラグを更新し、画面から消去する仕組みを構築した。

## 3. トラブルシューティング
### 通知が閉じられない、またはリロードで復活する問題
- **現象**: 画面上の「×」ボタンを押してもDB上のデータが更新されず、再読み込みすると通知が再表示された。
- **対策**: 単なるJavaScriptによる要素削除ではなく、`<form>` を用いてサーバー側の既読更新用エンドポイント（`/notifications/{id}/read`）を呼び出す構成に変更した。



## 4. 学習成果
- バッチ処理（静的な自動処理）とユーザー操作（動的な画面表示）を、DBを介して疎結合に連携させる設計パターンを理解した。
- エンティティ間の関連（`@ManyToOne`）を適切に設定することで、より高度なクエリ（`existsByTaskId...`）が生成できることを学んだ。