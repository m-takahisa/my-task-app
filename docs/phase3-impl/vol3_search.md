# 学習ログ Vol.3：検索・抽出機能の実装

## 1. 概要
タスク一覧画面において、ユーザーが目的のタスクを素早く見つけられるよう、タイトルによるキーワード検索（部分一致）およびステータスによるフィルタリング機能を実装した。

## 2. 実装のポイント
### ① Spring Data JPA Query Methods の活用
メソッド名に基づいたクエリ自動生成機能を利用し、複雑なSQLを書くことなく検索ロジックを実装した。
- `findByTitleContaining`: `LIKE %keyword%` による部分一致検索。
- `findByStatus`: Enum型による完全一致検索。
- `findByTitleContainingAndStatus`: 複数条件（AND）の組み合わせ検索。

### ② ステータス管理の最適化（Enum化）
`String` 型で管理していたステータスを `TaskStatus` Enumへ移行した。
- **利点**: 不正な文字列の混入を防ぐ（型安全）、IDEの補完が効く、表示名（displayName）を一元管理できる。
- **DB連携**: `@Enumerated(EnumType.STRING)` を使用し、DBには文字列として保存することで可読性を維持。

### ③ ユーザー体験（UX）の向上
- 検索実行後も、入力したキーワードや選択したステータスがリセットされないよう、`Model` オブジェクトを介して値をフォームへ還元する仕組みを構築した。

## 3. トラブルシューティング
### 検索ロジックの優先順位によるバグ
- **現象**: ステータスで「すべてのステータス（null）」を選択した際、キーワードを入力していても全件表示されてしまう不具合が発生。
- **原因**: `if (status != null)` の判定を優先していたため、ステータスが未指定の場合にキーワードの有無に関わらず全件取得（`findAll`）のフローへ流れていた。
- **対策**: 条件分岐を整理し、「キーワードの有無」を最優先の判定基準に変更。キーワードがある場合はその中でステータスの有無を判定するネスト構造にリファクタリングすることで解決した。



## 4. 学習成果
- Spring Data JPA の命名規則によるクエリ生成の強力さと限界（複雑すぎる場合は `@Query` や `Specification` が必要になる点）を理解した。
- 画面（View）、制御（Controller）、ロジック（Service）、データ（Repository）の各レイヤーにおける適切なデータ受け渡し方法を習得した。